fe分为两个层次：基础组件层和协作层。

基础组件层：
以AI Agent为核心，模块包括：
{环境： 为智能体提供协作工作空间和交流平台。
记忆：存储和检索历史消息。
角色：根据领域封装专业技能和工作流程。
行动：执行模块化的子任务。
工具：提供常见的服务和工具。}


协作层：
建立在基础组件之上，提供两种基本机制
{知识共享：允许智能体有效地交换信息。智能体可以以不同粒度存储、检索和共享数据。
封装工作流程：利用SOP将复杂任务分解为小的、可管理的子任务。将这些任务分配给适合的智能体，并对其进行监控。

MetaGPT实现机制：
角色定义{
基础角色属性定义：名称、简介、目标、约束和描述。
思考与反思（Think & Reflect）：角色可以检索角色描述构建思考，然后通过_think()函数反思需要做什么并决定下一步行动。
观察（Observe）：角色观察环境，根据观察结果使用_observe()函数进行思考和行动，他们会关注重要信息并纳入记忆中丰富上下文理解。
广播消息（Broadcast messages）：角色可以使用_publish_message()函数将消息广播到环境，信息包含当前执行结果和相关行动的详细信息，用于发布和共享信息。
知识沉淀与行动（Knowledge precipitation & act）：角色不仅是传播，更是信息接收者。角色评估传入的信息的相关性和及时性，从共享环境中提取相关知识，并维护一个内部的知识库以支持决策。通过咨询LLM,并利用上下文信息和自我知识来执行行动。执行结果封装为消息。
状态管理（state management）：角色通过更新工作状态和监控待办事项跟踪行动。使角色能按顺序处理多个行动不中断。在执行行动时，角色首先锁定状态。完成行动后，状态标记为解锁。防止其他行动中断工作流程。
}
实例化SOP的Prompt{
使用提示来实例化SOP，并提供逐步指导。
Action类作为智能体执行特定任务的原子单位，关键属性包括{
前缀（Prefix）：将角色特定前缀注入提示，建立角色上下文，使用set_prefix（）方法配置特定提示的标识符。
LLM代理（LLM proxy）：每个Action包含一个llm代理，可通过aask（）调用该代理，使用自然语言丰富行动细节。可以在Action类中实现各种角色的上下文解析函数，从输入中提取并提供足够上下文信息给LLM。
标准化的输出模式（Standardized outputs schema）：使用结构化表示定义预期的输出模式，提取结构化数据，标准化输出模式。
重试机制（Retry mechanism）：通过定义尝试次数和等待时间实现对行动进行充实，提高稳健性。
}
标准化输出的行动{
每个行动的标准化输出保障了LLM结果符合智能体的责任范围。
}
知识共享机制和自定义知识管理{
每个智能体从共享环境日志中检索相关历史信息，主动策划个性化知识。基于智能体基于角色兴趣提取相关信息。
每个智能体都维护一个内存缓存，并对其角色相关的订阅消息进行索引，实现个性化的知识策划。消息集中创建了一个统一的数据源，在内部智能体通过内容、来源和属性将内存缓存索引来在相关上下文中实现快速检索。
消息共享：当一个智能体生成一条消息，它被复制到共享的环境日志，创建但艺术剧院，确保所有智能体获得相同的信息。
基于角色的订阅：智能体根据角色对其有意义的消息类型进行注册订阅。
消息分发：当有新的消息符合订阅条件，它自动分发通知给相关智能体，可以防止智能体错过重要信息。
内存缓存和索引：智能体会维护一个内部的记忆缓存，订阅的消息会按内容、发送者和接收者建立索引来存储，从而保障高效的信息存储和检索。
上下文检索：环境会维护一个支持缓存和索引的共享内存池。同时，智能体根据需要查询其内部内存，获取与其当前任务相关的上下文细节，改进其理解并做出更好的决策。
更新同步：对消息进行的任何更新或更改都会在连接的智能体内存中同步。
通过智能体周围对信息流进行组织，确保多智能体之间的协作。使其在团队协作和个人效率之间达成平衡。

MetaGPT框架：
实现一个单动作的agent：
在此之前，写一个Action的子类继承action，这个即为该agent的动作
重写Role基类的_init_和_act函数，并在init函数中声明Agent的name(名称)profile(基类)。
使用self._set_action函数将子类action添加到Role基类中作为动作。
在_act函数中，编写智能体具体的新工党逻辑，智能体将从最新记忆获取人类指令，运行配备动作，并将其放入self._rc.todo中。
	编写动作：
	用户可以通过调用self._aask函数获取LLM回复。
	编写一个SimpleWriterCode：PROMPT_TEMPLATE="""
创建一个动作类，创建一个角色类，将动作类放到角色类中
之后可以用一个角色类的_watch函数检测，一旦前面的函数返回了Message则该动作接收上游信息。
environment将各个role串联起来。
think函数用来咨询llm下一个状态应该采取什么动作，返回一个索引。


https://juejin.cn/post/7369853533917691915
https://www.cnblogs.com/passion2021/p/17976349
	



